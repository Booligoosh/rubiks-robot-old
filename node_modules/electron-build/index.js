#!/usr/bin/env node --harmony
/* App to upload a package for processing */
var request = require('request'),
    Q = require('Q'),
    fs = require('fs'),
    co = require('co'),
    prompt = require('co-prompt'),
    program = require('commander'),
    url = require('url'),
    path = require('path'),
    progbar = require('progress'),
    zip = require('./zip.js');

var baseURL = 'https://electronbuild.azurewebsites.net';
var username = '';
var password = '';
var waiting = false;
program
    .version('0.0.1')
//    .option('-f, --file <filename>', 'Zip file to upload to Electron Build (containing your index.html and other assets)')
//    .option('-z, --zip <folder>', 'Zip a folder containing index.html and other files, then upload to Electron Build')
    .option('-u, --username <username>', 'Your username at electronbuild.com')
    .option('-p, --password <password>', 'Your password at electronbuild.com')
    .option('-a, --app <appname>', 'Specify the applications name (alternatively you can specify the appid)')
    .option('-l, --list', 'List your Electron Build apps')    
    .option('-sw, --skipwait', 'Dont wait to download installations. Just upload to Electron Build for processing')
    .option('-v, --verbose', 'Verbose information')
    .action(function (file) {
        program.zip = file;            
    })
    .parse(process.argv);

program.on('--help', function () {
    console.log('Example:');
    console.log('ebuild c:\\pathToMySource --app MyApp -u myusername@blar.com -p secretpassword --download');
    console.log('This example will upload the file myapp.zip for application id 134 and once processed will download the installer for it');
});

if (!process.argv.slice(2).length) {
    program.outputHelp();
    process.exit(0);
}

co(function* () {
    if ((!program.username) || (!program.password)) {
        console.log();
        console.log('Electron Build CLI (electronbuild.com)');
        console.log('======================================');
        console.log('Please enter your credentials');
        program.username = yield prompt('username: ');
        program.password = yield prompt.password('password: ');
    }
    program.appName = program.app;
    program.download = true;
    if (program.skipwait) {
        program.download = false;
    }
    go();
});

function verbose(message) {
    if (program.verbose) {
        console.log(message);
    }
}

/** Do the work */
function go() {
    var op = listApps;
    if (program.wait) {
        op = waitForProcessing;
    }
    if (program.zip) {
        op = zipFolder;
    }
    if (program.file) {
        // Upload a file
        op = uploadPackage;
    }
        
    getToken(program.username, program.password).then((token) => {
        if (isNaN(program.app)) {
            getAppIdFor(token, program.app).then(() => { op(token); });
        } else {
            op(token);
        }
    }, displayError);
}

/** Create/Get an AppId for the app name */
function getAppIdFor(token, app) {
    var deferred = Q.defer();
    verbose('Getting AppId for ' + app);
    request.get({
        url: baseURL + '/api/application/' + app,
        json: true,
        headers: { 'Authorization': 'Bearer ' + token }
    }, function (error, response, appId) {
        program.app = appId;
        verbose('AppId=' + appId);
        if (isNaN(appId)) {
            verbose('Error: AppId returned as ' + appId);
            return deferred.reject();
        }
        return deferred.resolve(appId);
    });
    return deferred.promise;
}

/** Display error in red */
function displayError(message) {
    error(message);
    process.exit(1);
}

/** Display error in red */
function error(message, abort) {
    console.error('\x1b[31m', message, '\x1b[0m');
    if (abort) process.exit(1);
}

/** List Electron Build Packages */
function listApps(token) {
    var deferred = Q.defer();
    verbose('Listing apps');
    request.get({
        url: baseURL + '/api/applications',
        json: true,
        headers: { 'Authorization': 'Bearer ' + token }
    }, function (error, response, apps) {
        var index = 1;
        apps.forEach(function (app) {
            app.Index = index++;
            if (program.app) {
                if (program.app == app.Id) {
                    listApp(app, token).then(
                        function () {
                            // List apps is complete
                            return deferred.resolve();
                        },
                        function () {
                            return deferred.reject();
                        });
                }
            } else {
                return listApp(app, token);
            }
        });
    });
    return deferred.promise;
}

/** List app */
function listApp(app, token) {
    var deferred = Q.defer();
    verbose('Listing app '+app);
    request.get({
        url: baseURL + '/api/applications/' + app.Id + '/downloads',
        json: true,
        headers: { 'Authorization': 'Bearer ' + token }
    }, function (error, response, downloads) {
        if (!downloads) {
            displayError('Nothing to download');
        }
        downloads.forEach(function (download) {
            var status = download.Status;
            status = ((status == null) || (status == 'Complete')) ? '' : '[' + status + ']';
            var b = new Date(Date.parse(download.BuildDateTime));
            var b2 = b.toLocaleTimeString("en-us", {
                weekday: "short", year: "numeric", month: "short",
                day: "numeric", hour: "2-digit", minute: "2-digit"
            });
            if (program.list) {
                console.log('"%s" v%s (AppId: %s) %s%s. Built on %s %s', app.Name, app.Version, app.Id, download.Platform, download.Architecture ? ' ' + download.Architecture : '', b2, status);
            }

            if (program.download) {
                // Only download if the package is complete                
                if (status !== '') {
                    return deferred.reject(status);
                }

                // Download the app
                downloadApp(download.Url, token).then(
                    function () { return deferred.resolve(); },
                    function () { return deferred.reject(); });
            }
        });
    });
    return deferred.promise;
}

/** Download an app */
function downloadApp(fileUrl, token) {
    var deferred = Q.defer();
    verbose('Downloading '+fileUrl);
    var parsed = url.parse(fileUrl);
    var filename = path.basename(parsed.pathname);
    if (!filename) displayError('Unable to download ' + fileUrl);
    var bar = null;
    fileStream = fs.createWriteStream(filename);
    request
        .get(fileUrl, function (e, r, b) {
            console.log('Download complete: ' + filename);
            deferred.resolve();
        })
        .on('data', function (data) {
            if (bar) { bar.tick(data.length); }
        })
        .on('error', function (err) {
            displayError(err);
        })
        .on('response', function (data) {
            var size = Number(data.headers['content-length']);
            var barOpts = { width: 20, total: size, clear: true, renderThrottle: 1000 };
            var mb = parseFloat(size / 1000000).toFixed(2);
            console.log('%s (%smb)', filename, mb);
            bar = new progbar('Downloading [:bar] :percent :etas ', barOpts);
        })
        .pipe(fileStream);
    return deferred.promise;
}

/** Upload a package */
function uploadPackage(token) {
    var deferred = Q.defer();
    try {
        var filename = program.file;
        var fullPath = path.resolve(filename);
        if (!fs.existsSync(fullPath)) {
            displayError('File ' + fullPath + ' doesnt exist');
        }
        var stats = fs.statSync(fullPath);
        var fileSizeInBytes = stats["size"];
        var stream = fs.createReadStream(fullPath);
        var barOpts = { width: 20, total: fileSizeInBytes, clear: true, renderThrottle: 1000 };
        var bar = new progbar('Uploading [:bar] :percent :etas ', barOpts);

        var formData = {
            file: { value: stream, options: { filename: filename } }
        };
        stream.on('data', function (data) {
            if (bar) { bar.tick(data.length); }
        });
        stream.on('error', function (err) {
            if (err.errno == -4058) {
                displayError('File doesnt exist: ' + filename);
            } else {
                displayError(err);
            }
        });
        console.log('Uploading '+program.appName);
        verbose('Uploading ' + filename);
        request.post({
            url: baseURL + '/api/packages/' + program.app + '?format=package',
            headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/x-zip-compressed' },
            formData: formData
        }, function (e, r, b) {
            if (b && b.indexOf('https://') == 0) {
                console.log(program.appName+' is now in the Electron Build queue.');
                if (program.download) {
                    // Wait until we are done processing
                    console.log('Waiting for packages to build....');
                    waiting = true;
                    waitForProcessing(token).then(function () {
                        return deferred.resolve();
                    }, function () {
                        return deferred.reject();
                    });
                }
            }
        });
    }
    catch (e) {
        console.error('uploadPackage Error', e);
        process.exit(1);
    }
    return deferred.promise;
}

/** Wait for all builds to finish */
function waitForProcessing(token) {
    var deferred = Q.defer();
    waitApp(program.app, token).then(
        function ok() {
            listApps(token).then(function () {
                deferred.resolve();
            });
        },
        function error() {
            setTimeout(waitForProcessing, 5000, token);
        }
    );
    return deferred.promise;
}

/** Wait until the app is processed */
function waitApp(id, token) {
    var deferred = Q.defer();
    request.get({
        url: baseURL + '/api/applications/' + id + '/downloads',
        json: true,
        headers: { 'Authorization': 'Bearer ' + token }
    }, function (error, response, downloads) {
        var complete = true;

        if (!downloads) {
            displayError('Nothing to download');
        }
        if (downloads.Message) {
            displayError(downloads.Message + ' Id is "' + id + '"');
        }
        downloads.forEach(function (download) {
            var status = download.Status;
            status = ((status == null) || (status == 'Complete')) ? '' : '[' + status + ']';
            if (status !== '') { complete = false; }
        });
        if (complete) {
            deferred.resolve();
        } else {
            deferred.reject();
        }
    });
    return deferred.promise;
}

/** Get Token from auth0.com */
function getToken(username, password) {
    var deferred = Q.defer();
    console.log('Authenticating...');
    request({
        url: 'https://electronbuild.auth0.com/oauth/ro',
        method: 'POST',
        json: true,
        body: {
            'Content-Type': 'application/json',
            'client_id': 'n0sV7m4Sk8Yypemu1h8QTNK9fvbS5oHv', // Electron Build
            'username': username,
            'password': password,
            'connection': 'Username-Password-Authentication',
            'grant_type': 'password',
            'scope': 'openid'
        }
    }, function (error, response, body) {
        if (body && body.error_description) {
            displayError(body.error_description);
            deferred.reject(body.error);
        } else {
            if (body.id_token) {
                console.log('Authenticated.');                
                deferred.resolve(body.id_token);
            } else {
                deferred.reject(body);
            }
        }
    });
    return deferred.promise;
}

/** Zip folder */
function zipFolder(token) {
    try {
        var filename = 'myapp.zip';
        var dir = path.resolve(program.zip);
        var stat = fs.lstatSync(dir);                
        verbose('creating ' + filename + ' from ' + program.zip + '/*.*');
        program.file = zip.zip(program.zip, filename);
        verbose('Wrote ' + program.file);
        uploadPackage(token).then(function () {
            console.log('Complete');
        }, function () {
            console.log('Failed');
        });
    }
    catch (err) {
        displayError(err);
    }
}
