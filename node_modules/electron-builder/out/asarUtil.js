"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkFileInArchive = exports.AsarPackager = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

let checkFileInArchive = exports.checkFileInArchive = (() => {
    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (asarFile, relativeFile, messagePrefix) {
        function error(text) {
            return new Error(`${messagePrefix} "${relativeFile}" in the "${asarFile}" ${text}`);
        }
        let fs;
        try {
            fs = yield (0, (_asar || _load_asar()).readAsar)(asarFile);
        } catch (e) {
            throw error(`is corrupted: ${e}`);
        }
        let stat;
        try {
            stat = fs.getFile(relativeFile);
        } catch (e) {
            const fileStat = yield (0, (_fs || _load_fs()).statOrNull)(asarFile);
            if (fileStat == null) {
                throw error(`does not exist. Seems like a wrong configuration.`);
            }
            // asar throws error on access to undefined object (info.link)
            stat = null;
        }
        if (stat == null) {
            throw error(`does not exist. Seems like a wrong configuration.`);
        }
        if (stat.size === 0) {
            throw error(`is corrupted: size 0`);
        }
    });

    return function checkFileInArchive(_x2, _x3, _x4) {
        return _ref2.apply(this, arguments);
    };
})();
//# sourceMappingURL=asarUtil.js.map


var _electronBuilderUtil;

function _load_electronBuilderUtil() {
    return _electronBuilderUtil = require("electron-builder-util");
}

var _fs;

function _load_fs() {
    return _fs = require("electron-builder-util/out/fs");
}

var _log;

function _load_log() {
    return _log = require("electron-builder-util/out/log");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _asar;

function _load_asar() {
    return _asar = require("./asar");
}

var _fileTransformer;

function _load_fileTransformer() {
    return _fileTransformer = require("./fileTransformer");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isBinaryFile = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify(require("isbinaryfile"));
const pickle = require("chromium-pickle-js");
const NODE_MODULES_PATTERN = `${_path.sep}node_modules${_path.sep}`;
function addValue(map, key, value) {
    let list = map.get(key);
    if (list == null) {
        list = [value];
        map.set(key, list);
    } else {
        list.push(value);
    }
}
function writeUnpackedFiles(filesToUnpack, fileCopier) {
    return (_bluebirdLst2 || _load_bluebirdLst2()).default.map(filesToUnpack, it => {
        if (it.data == null) {
            return fileCopier.copy(it.src, it.destination, it.stats);
        } else {
            return (0, (_fsExtraP || _load_fsExtraP()).writeFile)(it.destination, it.data);
        }
    });
}
class AsarPackager {
    constructor(src, destination, options, unpackPattern, transformer) {
        this.src = src;
        this.options = options;
        this.unpackPattern = unpackPattern;
        this.transformer = transformer;
        this.fs = new (_asar || _load_asar()).AsarFilesystem(this.src);
        this.metadata = new Map();
        this.outFile = _path.join(destination, "app.asar");
    }
    // sort files to minimize file change (i.e. asar file is not changed dramatically on small change)
    pack(filter, isElectronCompile) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const metadata = _this.metadata;
            let files = yield (0, (_fs || _load_fs()).walk)(_this.src, filter, function (file, fileStat) {
                metadata.set(file, fileStat);
                if (fileStat.isSymbolicLink()) {
                    return (0, (_fsExtraP || _load_fsExtraP()).readlink)(file).then(function (linkTarget) {
                        // http://unix.stackexchange.com/questions/105637/is-symlinks-target-relative-to-the-destinations-parent-directory-and-if-so-wh
                        const resolved = _path.resolve(_path.dirname(file), linkTarget);
                        const link = _path.relative(_this.src, linkTarget);
                        if (link.startsWith("..")) {
                            // outside of project, linked module (https://github.com/electron-userland/electron-builder/issues/675)
                            return (0, (_fsExtraP || _load_fsExtraP()).stat)(resolved).then(function (targetFileStat) {
                                metadata.set(file, targetFileStat);
                                return targetFileStat;
                            });
                        } else {
                            fileStat.relativeLink = link;
                        }
                        return null;
                    });
                }
                return null;
            });
            // transform before electron-compile to avoid filtering (cache files in any case should be not transformed)
            const transformer = _this.transformer;
            _this.transformedFiles = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(files, function (it) {
                return metadata.get(it).isFile() ? transformer(it) : null;
            }, (_fs || _load_fs()).CONCURRENCY);
            if (isElectronCompile) {
                files = yield _this.compileUsingElectronCompile(files);
            }
            yield _this.createPackageFromFiles(_this.options.ordering == null ? files : yield _this.order(files));
        })();
    }
    compileUsingElectronCompile(files) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            (0, (_log || _load_log()).log)("Compiling using electron-compile");
            const metadata = _this2.metadata;
            const cacheDir = _path.join(_this2.src, ".cache");
            // clear and create cache dir
            yield (0, (_fsExtraP || _load_fsExtraP()).emptyDir)(cacheDir);
            const compilerHost = yield (0, (_fileTransformer || _load_fileTransformer()).createElectronCompilerHost)(_this2.src, cacheDir);
            const nextSlashIndex = _this2.src.length + 1;
            // pre-compute electron-compile to cache dir - we need to process only subdirectories, not direct files of app dir
            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(files, function (file) {
                if (file.indexOf("/node_modules/") !== -1 || file.indexOf("/bower_components/") !== -1 || !(file.indexOf("/", nextSlashIndex) !== -1) // ignore not root files 
                || !metadata.get(file).isFile()) {
                    return null;
                }
                return compilerHost.compile(file).then(function (it) {
                    return null;
                });
            }, (_fs || _load_fs()).CONCURRENCY);
            yield compilerHost.saveConfiguration();
            const cacheFiles = yield (0, (_fs || _load_fs()).walk)(cacheDir, function (file, stat) {
                return !file.startsWith(".");
            }, function (file, fileStat) {
                _this2.metadata.set(file, fileStat);
                return null;
            });
            // add es6-shim.js
            const es6ShimPath = `${_this2.src}/es6-shim.js`;
            cacheFiles.push(es6ShimPath);
            metadata.set(es6ShimPath, { isFile: function () {
                    return true;
                }, isDirectory: function () {
                    return false;
                } });
            _this2.transformedFiles = new Array(cacheFiles.length).concat(_this2.transformedFiles);
            _this2.transformedFiles[cacheFiles.length - 1] = yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.join(_this2.src, "node_modules", "electron-compile", "lib", "es6-shim.js"));
            // cache files should be first (better IO)
            return cacheFiles.concat(files);
        })();
    }
    detectUnpackedDirs(files, autoUnpackDirs, unpackedDest) {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const dirToCreate = new Map();
            const metadata = _this3.metadata;
            /* tslint:disable:rule1 prefer-const */
            for (let i = 0, n = files.length; i < n; i++) {
                const file = files[i];
                const index = file.lastIndexOf(NODE_MODULES_PATTERN);
                if (index < 0) {
                    continue;
                }
                const nextSlashIndex = file.indexOf(_path.sep, index + NODE_MODULES_PATTERN.length + 1);
                if (nextSlashIndex < 0) {
                    continue;
                }
                if (!metadata.get(file).isFile()) {
                    continue;
                }
                const nodeModuleDir = file.substring(0, nextSlashIndex);
                if (autoUnpackDirs.has(nodeModuleDir)) {
                    const fileParent = _path.dirname(file);
                    if (fileParent !== nodeModuleDir && !autoUnpackDirs.has(fileParent)) {
                        autoUnpackDirs.add(fileParent);
                        addValue(dirToCreate, _path.relative(_this3.src, nodeModuleDir), _path.relative(nodeModuleDir, fileParent));
                    }
                    continue;
                }
                const ext = _path.extname(file);
                let shouldUnpack = false;
                if (ext === ".dll" || ext === ".exe") {
                    shouldUnpack = true;
                } else if (ext === "") {
                    shouldUnpack = yield isBinaryFile(file);
                }
                if (!shouldUnpack) {
                    continue;
                }
                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(`${_path.relative(_this3.src, nodeModuleDir)} is not packed into asar archive - contains executable code`);
                let fileParent = _path.dirname(file);
                // create parent dir to be able to copy file later without directory existence check
                addValue(dirToCreate, _path.relative(_this3.src, nodeModuleDir), _path.relative(nodeModuleDir, fileParent));
                while (fileParent !== nodeModuleDir) {
                    autoUnpackDirs.add(fileParent);
                    fileParent = _path.dirname(fileParent);
                }
                autoUnpackDirs.add(nodeModuleDir);
            }
            if (dirToCreate.size > 0) {
                // child directories should be not created asynchronously - parent directories should be created first
                yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(dirToCreate.keys(), (() => {
                    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (it) {
                        const base = _path.join(unpackedDest, it);
                        yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(base);
                        yield (_bluebirdLst2 || _load_bluebirdLst2()).default.each(dirToCreate.get(it), function (it) {
                            return (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.join(base, it));
                        });
                    });

                    return function (_x) {
                        return _ref.apply(this, arguments);
                    };
                })(), (_fs || _load_fs()).CONCURRENCY);
            }
        })();
    }
    createPackageFromFiles(files) {
        var _this4 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const metadata = _this4.metadata;
            // search auto unpacked dir
            const unpackedDirs = new Set();
            const unpackedDest = `${_this4.outFile}.unpacked`;
            yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.dirname(_this4.outFile));
            if (_this4.options.smartUnpack !== false) {
                yield _this4.detectUnpackedDirs(files, unpackedDirs, unpackedDest);
            }
            const dirToCreateForUnpackedFiles = new Set(unpackedDirs);
            const transformedFiles = _this4.transformedFiles;
            const filesToUnpack = [];
            const fileCopier = new (_fs || _load_fs()).FileCopier();
            /* tslint:disable:rule1 prefer-const */
            for (let i = 0, n = files.length; i < n; i++) {
                const file = files[i];
                const stat = metadata.get(file);
                if (stat.isFile()) {
                    const fileParent = _path.dirname(file);
                    const dirNode = _this4.fs.getOrCreateNode(fileParent);
                    const newData = transformedFiles == null ? null : transformedFiles[i];
                    const node = _this4.fs.getOrCreateNode(file);
                    node.size = newData == null ? stat.size : Buffer.byteLength(newData);
                    if (dirNode.unpacked || _this4.unpackPattern != null && _this4.unpackPattern(file, stat)) {
                        node.unpacked = true;
                        if (newData != null) {
                            transformedFiles[i] = null;
                        }
                        if (!dirNode.unpacked && !dirToCreateForUnpackedFiles.has(fileParent)) {
                            dirToCreateForUnpackedFiles.add(fileParent);
                            yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(fileParent.replace(_this4.src, unpackedDest));
                        }
                        const unpackedFile = file.replace(_this4.src, unpackedDest);
                        filesToUnpack.push(newData == null ? { src: file, destination: unpackedFile, stats: stat } : { destination: unpackedFile, data: newData, stats: stat });
                        if (filesToUnpack.length > (_fs || _load_fs()).MAX_FILE_REQUESTS) {
                            yield writeUnpackedFiles(filesToUnpack, fileCopier);
                            filesToUnpack.length = 0;
                        }
                    } else {
                        if (newData == null) {
                            transformedFiles[i] = true;
                        }
                        _this4.fs.insertFileNode(node, stat, file);
                    }
                } else if (stat.isDirectory()) {
                    let unpacked = false;
                    if (unpackedDirs.has(file)) {
                        unpacked = true;
                    } else {
                        for (const dir of unpackedDirs) {
                            if (file.length > dir.length + 2 && file[dir.length] === _path.sep && file.startsWith(dir)) {
                                unpacked = true;
                                unpackedDirs.add(file);
                                // not all dirs marked as unpacked after first iteration - because node module dir can be marked as unpacked after processing node module dir content
                                // e.g. node-notifier/example/advanced.js processed, but only on process vendor/terminal-notifier.app module will be marked as unpacked
                                yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(file.replace(_this4.src, unpackedDest));
                                break;
                            }
                        }
                    }
                    _this4.fs.insertDirectory(file, unpacked);
                } else if (stat.isSymbolicLink()) {
                    _this4.fs.getOrCreateNode(file).link = stat.relativeLink;
                }
            }
            if (filesToUnpack.length > 0) {
                yield writeUnpackedFiles(filesToUnpack, fileCopier);
            }
            yield _this4.writeAsarFile(files);
        })();
    }
    writeAsarFile(files) {
        const headerPickle = pickle.createEmpty();
        headerPickle.writeString(JSON.stringify(this.fs.header));
        const headerBuf = headerPickle.toBuffer();
        const sizePickle = pickle.createEmpty();
        sizePickle.writeUInt32(headerBuf.length);
        const sizeBuf = sizePickle.toBuffer();
        const transformedFiles = this.transformedFiles;
        const writeStream = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(this.outFile);
        return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
            writeStream.on("error", reject);
            writeStream.on("close", resolve);
            writeStream.write(sizeBuf);
            const w = index => {
                let data;
                while (true) {
                    if (index >= files.length) {
                        writeStream.end();
                        return;
                    }
                    if ((data = transformedFiles[index++]) != null) {
                        break;
                    }
                }
                const file = files[index - 1];
                if (data !== true) {
                    writeStream.write(data, () => w(index));
                    return;
                }
                const readStream = (0, (_fsExtraP || _load_fsExtraP()).createReadStream)(file);
                readStream.on("error", reject);
                readStream.once("end", () => w(index));
                readStream.pipe(writeStream, {
                    end: false
                });
            };
            writeStream.write(headerBuf, () => w(0));
        });
    }
    order(filenames) {
        var _this5 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const orderingFiles = (yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_this5.options.ordering, "utf8")).split("\n").map(function (line) {
                if (line.indexOf(":") !== -1) {
                    line = line.split(":").pop();
                }
                line = line.trim();
                if (line[0] === "/") {
                    line = line.slice(1);
                }
                return line;
            });
            const ordering = [];
            for (const file of orderingFiles) {
                const pathComponents = file.split(_path.sep);
                let str = _this5.src;
                for (const pathComponent of pathComponents) {
                    str = _path.join(str, pathComponent);
                    ordering.push(str);
                }
            }
            const filenamesSorted = [];
            let missing = 0;
            const total = filenames.length;
            for (const file of ordering) {
                if (!(filenamesSorted.indexOf(file) !== -1) && filenames.indexOf(file) !== -1) {
                    filenamesSorted.push(file);
                }
            }
            for (const file of filenames) {
                if (!(filenamesSorted.indexOf(file) !== -1)) {
                    filenamesSorted.push(file);
                    missing += 1;
                }
            }
            (0, (_log || _load_log()).log)(`Ordering file has ${(total - missing) / total * 100}% coverage.`);
            return filenamesSorted;
        })();
    }
}
exports.AsarPackager = AsarPackager;